includeConfig "${projectDir}/external/pipeline-Nextflow-config/config/csv/csv_parser.config"

/**
*   Namespace for handling input parsing and parameter settings based on inputs
*/
input_handler {
    /**
    *   Verify inputs and determine input type
    */
    check_inputs = {
        if (!params.containsKey('input')) {
            throw new IllegalArgumentException("No input found! Please run pipeline with inputs.");
        }

        def given_input_types = [] as Set;
        def given_src_types = [] as Set;
        def samples_found = [];
        params.input.each { patient, patient_data ->
            patient_data.each { sample, sample_data ->
                if (samples_found.contains(sample)) {
                    raise IllegalArgumentException("Found duplicate sample: `${sample}`. Samples given must be unique!")
                }
                def sample_input_keys = sample_data.keySet() as List;
                sample_input_keys.removeAll{ it == 'state' };
                if (sample_input_keys.contains('CRAM')) {
                    sample_input_keys.removeAll{ it == 'CRAM' };
                    sample_input_keys.add('BAM');
                    sample_data['BAM'] = sample_data['CRAM'];
                    sample_data.remove('CRAM');
                }
                sample_input_keys.each { sample_input_type -> given_input_types.add(sample_input_type) };

                if (sample_input_keys.contains('SRC')) {
                    def sample_src_types = [] as Set;
                    sample_data.SRC.each { src_input ->
                        sample_src_types.add(src_input.src_input_type);
                    }

                    given_src_types.add(sample_src_types as List);
                    assert given_src_types[0].sort() == given_src_types[-1].sort()
                        : "Received mismatching SRC input types: `${given_src_types[0]}` and `${given_src_types[-1]}`. If SRC input is given, the same types must be given for all samples."
                }
            }
        }

        String input_type = null;

        if (given_input_types.isEmpty()) {
            raise IllegalArgumentException("No expected inputs found! Please ensure the inputs contain proper inputs including either BAM/CRAM or FASTQ and optionally SRC")
        }

        Boolean src_input_given = false;
        if (given_input_types.contains('SRC')) {
            src_input_given = true;
            given_input_types.removeAll{ it == 'SRC' };
            input_type = 'SRC';
        }

        // Only one of FASTQ and BAM is allowed if given
        if (!given_input_types.isEmpty()) {
            assert given_input_types.size() == 1 : "Expected only one of BAM/CRAM or FASTQ for sequence input but received `${given_input_types}`";
            input_type = given_input_types[0];
        }

        // A single input type should be left
        params.input_type = input_type;
        params.src_input_given = src_input_given;
        params.src_input_types = src_input_given ? given_src_types[0] : null;
    }

    /**
    *   Get sample counts from input
    */
    set_sample_counts = {
        Map sample_counts = [:];
        params.input.each { patient, patient_data ->
            if (!sample_counts.containsKey(patient)) {
                sample_counts[patient] = ['normal': 0, 'tumor': 0];
            }
            patient_data.each { sample, sample_data ->
                sample_counts[patient][sample_data.state] += 1;
            }
        }

        params.sample_counts = sample_counts;
    }

    /**
    *   Check identified counts and run mode
    */
    check_sample_counts = {
        if (params.sample_mode != 'single') {
            if (!params.sample_counts.every { patient, counts -> counts.normal == 1 }) {
                throw new Exception("Patients with multiple normal samples or no normal sample found! Please run the metapipeline with a single normal sample per patient.");
            }
        }

        return;
    }

    /**
    *   Generate structure for default data
    */
    get_default_data_map = {
        Map alignment_outputs = [:];
        List aligners = params.pipeline_params.align_DNA.aligner ?: ['BWA-MEM2'];
        aligners.each{ aligner_tool ->
            alignment_outputs[aligner_tool] = ['BAM':''];
        }
        Map default_data_map = [
            'align-DNA': alignment_outputs,
            'recalibrate-BAM': ['BAM':'', 'contamination_table':''],
            'calculate-targeted-coverage': ['expanded-intervals': ''],
            'convert-BAM2FASTQ': []
        ];

        return default_data_map;
    }

    /**
    *   Generate the sample data structure for the pipeline run
    */
    generate_sample_data_map = {
        Map all_sample_data = [:];
        List original_data_keys = [];

        if (params.input_type == 'BAM') {
            original_data_keys = ['path'];
        } else {
            original_data_keys = [
                'read_group_identifier',
                'sequencing_center',
                'library_identifier',
                'platform_technology',
                'platform_unit',
                'bam_header_sm',
                'lane',
                'read1_fastq',
                'read2_fastq'
            ];
        }

        List original_src_data_keys = [
            'src_input_type',
            'algorithm',
            'path'
        ];

        params.input.each { patient, patient_data ->
            patient_data.each { sample, sample_data ->
                String sample_state = sample_data.state;

                Object original_data = (params.input_type == 'BAM') ? [:] : [];
                List original_src_data = [];
                Map curr_data = [:];
                if (params.input_type != 'SRC') { // Handle the BAM/CRAM or FASTQ input
                    if (params.input_type == 'BAM') {
                        original_data_keys.each{ data_key -> original_data[data_key] = sample_data[params.input_type][data_key] };
                    } else {
                        sample_data[params.input_type].each { sample_input ->
                            curr_data = [:];
                            original_data_keys.each{ data_key -> curr_data[data_key] = sample_input[data_key] };
                            original_data += curr_data;
                        }
                    }
                }

                if (params.src_input_given) { // Handle the SRC input if given
                    sample_data['SRC'].each { sample_input ->
                        curr_data = [:];
                        original_src_data_keys.each{ data_key -> curr_data[data_key] = sample_input[data_key] };
                        original_src_data += curr_data;
                    }
                }

                Map default_data = input_handler.get_default_data_map();
                default_data += [
                    'patient': patient,
                    'state': sample_state,
                    'original_data': original_data,
                    'original_src_data': original_src_data
                ];

                all_sample_data[sample] = default_data;
            }
        }

        params.sample_data = all_sample_data;
        return;
    }

    /**
    *   Main function to handle input parsing and parameter setting
    */
    handle_inputs = {
        input_handler.check_inputs();
        input_handler.set_sample_counts();
        input_handler.check_sample_counts();
        input_handler.generate_sample_data_map();
        return;
    }
}
