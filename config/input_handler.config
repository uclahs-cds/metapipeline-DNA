includeConfig "${projectDir}/external/pipeline-Nextflow-config/config/csv/csv_parser.config"

/**
*   Namespace for handling input parsing and parameter settings based on inputs
*/
input_handler {
    /**
    *   Parse the input from CSV or YAML into a common format matching automatically loaded YAML input
    */
    parse_input = {
        if (params.containsKey('input')) { // if params.input exists then YAML input is used
            if (params.input.size() > 1) {
                throw new Exception("More than one input is specified in the YAML, please choose one of BAM or CRAM or FASTQ or SRC");
            }
            if (params.input.containsKey('CRAM')) {
                params.input.BAM = params.input.CRAM;
                params.input.remove('CRAM');
            }
        } else if (params.containsKey('input_csv')) { // check if CSV input is used
            reader = new BufferedReader(new FileReader(params.input_csv));
            header_line = reader.readLine().split(','); // reads first line of input csv file and split by comma into list
            if (header_line.contains('read1_fastq')) { // for FASTQ csv
                def fastq_input_fields = ['patient', 'sample', 'state', 'read_group_identifier', 'sequencing_center', 'library_identifier', 'platform_technology', 'platform_unit', 'bam_header_sm', 'lane', 'read1_fastq', 'read2_fastq'];
                params.input.FASTQ = csv_parser.parse_csv(params.input_csv, fastq_input_fields);
                if (!params.input.FASTQ.every { input_line -> input_line.sample == input_line.bam_header_sm }) {
                    throw new Exception("Input FASTQs must have matching sample and bam_hedaer_sm!");
                }
            } else if (header_line.contains('src_input_type')) { // for SRC input
                def src_input_fields = ['patient', 'sample', 'state', 'src_input_type', 'algorithm', 'path'];
                params.input.SRC = csv_parser.parse_csv(params.input_csv, src_input_fields);
            } else if (header_line.contains('path')) { // for BAM/CRAM csv
                def bam_input_fields = ['patient', 'sample', 'state', 'path'];
                params.input.BAM = csv_parser.parse_csv(params.input_csv, bam_input_fields);
            } else {
                throw new Exception("Input CSV does not follow the format for either BAM/CRAM or FASTQ or SRC inputs");
            }
        } else {
            throw new Exception("Neither YAML nor CSV inputs found! Please run pipeline with inputs.");
        }

        params.input_type = 'FASTQ';
        if (params.input.containsKey('BAM')) {
            params.input_type = 'BAM';
        } else if (params.input.containsKey('SRC')) {
            params.input_type = 'SRC';
        }

        return;
    }

    /**
    *   Verify inputs and determine input type
    */
    check_inputs = {
        if (!params.containsKey('input')) {
            throw new IllegalArgumentException("No input found! Please run pipeline with inputs.");
        }

        def given_input_types = [] as Set;
        params.input.each { patient, patient_data ->
            patient_data.each { sample, sample_data ->
                def sample_input_keys = sample_data.keySet() as List;
                if (sample_input_keys.contains('CRAM')) {
                    sample_input_keys.removeAll{ it == 'CRAM' };
                    sample_input_keys.add('BAM');
                }
                sample_input_keys.each { sample_input_type -> given_input_types.add(sample_input_type) };
            }
        }

        // Only one of FASTQ and BAM is allowed
        def expected_number_types = 1
        def src_input_given = false;
        if (given_input_types.contains('SRC')) {
            expected_number_types = expected_number_types + 1;
            src_input_given = true;
        }

        if (given_input_types.size() != expected_number_types) {
            throw new IllegalArgumentException("Expected one of BAM/CRAM or FASTQ and optionally SRC in the input but received: ${given_input_types}");
        }

        given_input_types.removeAll{ it == 'SRC' };

        // A single input type should be left
        params.input_type = given_input_types[0];
        params.src_input_given = src_input_given;
    }

    /**
    *   Get sample counts from input
    */
    set_sample_counts = {
        Map sample_counts = [:];
        params.input[params.input_type].collect{ ['patient': it['patient'], 'sample': it['sample'], 'state': it['state']] }.unique().collect{ sample_input ->
            if (!sample_counts.containsKey(sample_input.patient)) {
                sample_counts[sample_input.patient] = ['normal': 0, 'tumor': 0];
            }

            sample_counts[sample_input.patient][sample_input.state] += 1;
        }

        params.sample_counts = sample_counts;

        if (params.sample_mode != 'single') {
            if (!params.sample_counts.every { patient, counts -> counts.normal == 1 }) {
                throw new Exception("Patients with multiple normal samples or no normal sample found! Please run the metapipeline with a single normal sample per patient.");
            }
        }

        return;
    }

    /**
    *   Generate structure for default data
    */
    get_default_data_map = {
        if (params.input_type == 'SRC') {
            Map default_data_map = [
                'original_data': []
            ];

            return default_data_map;
        }

        Map alignment_outputs = [:];
        List aligners = params.pipeline_params.align_DNA.aligner ?: ['BWA-MEM2'];
        aligners.each{ aligner_tool ->
            alignment_outputs[aligner_tool] = ['BAM':''];
        }
        Map default_data_map = [
            'align-DNA': alignment_outputs,
            'recalibrate-BAM': ['BAM':'', 'contamination_table':''],
            'calculate-targeted-coverage': ['expanded-intervals': ''],
            'convert-BAM2FASTQ': [],
            'original_data': ((params.input_type == 'FASTQ') ? [] : [:])
        ];

        return default_data_map;
    }

    /**
    *   Generate the sample data structure for the pipeline run
    */
    generate_sample_data_map = {
        Map sample_data = [:];
        List original_data_keys = [];
        if (params.input_type == 'BAM') {
            original_data_keys = ['path'];
        } else if (params.input_type == 'SRC') {
            original_data_keys = [
                'src_input_type',
                'algorithm',
                'path'
            ];
        } else {
            original_data_keys = [
                'read_group_identifier',
                'sequencing_center',
                'library_identifier',
                'platform_technology',
                'platform_unit',
                'bam_header_sm',
                'lane',
                'read1_fastq',
                'read2_fastq'
            ];
        }

        params.input[params.input_type].each { sample_map ->
            String patient = sample_map['patient'];
            String sample_id = sample_map['sample'];
            String sample_state = sample_map['state'];

            Map original_data = [:];
            original_data_keys.each{ data_key -> original_data[data_key] = sample_map[data_key] };

            Map default_data = input_handler.get_default_data_map();
            default_data += [
                'patient': patient,
                'state': sample_state
            ];

            if (params.input_type == 'FASTQ' || params.input_type == 'SRC') {
                if (!sample_data.containsKey(sample_id)) {
                    sample_data[sample_id] = default_data;
                }

                sample_data[sample_id]['original_data'] += original_data;
            } else {
                default_data['original_data'] = original_data;
                sample_data[sample_id] = default_data;
            }
        }

        params.sample_data = sample_data;
        return;
    }

    /**
    *   Main function to handle input parsing and parameter setting
    */
    handle_inputs = {
        input_handler.parse_input();
        input_handler.set_sample_counts();
        input_handler.generate_sample_data_map();
        return;
    }
}
