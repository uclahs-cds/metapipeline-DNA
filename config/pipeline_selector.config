/**
*   This namespace contains the function needed for selecting pipelines to run for metapipeline-DNA
*/
pipeline_selector {
    /**
    *   Set the pipeline dependencies based on the input type
    */
    get_pipeline_dependencies = { String input_type='BAM' ->
        def dependencies = [
            'recalibrate-BAM': ['align-DNA'],
            'calculate-targeted-coverage': ['align-DNA'],
            'generate-SQC-BAM': ['recalibrate-BAM'],
            'call-gSNP': ['recalibrate-BAM'],
            'call-sSNV': ['recalibrate-BAM'],
            'call-mtSNV': ['recalibrate-BAM'],
            'call-gSV': ['recalibrate-BAM'],
            'call-sSV': ['recalibrate-BAM'],
            'call-sCNA': ['recalibrate-BAM'],
            'call-SRC': ['call-sSNV', 'call-sCNA']
            ]

        if (input_type == 'BAM') {
            dependencies['convert-BAM2FASTQ'] = []
            dependencies['align-DNA'] = ['convert-BAM2FASTQ']
        } else if (input_type == 'FASTQ' || input_type == 'SRC') {
            dependencies['align-DNA'] = []
        } else {
            throw new Exception("### ERROR ### Found unexpected input type: `${input_type}`. Please select from: BAM, FASTQ, SRC")
        }

        return dependencies
    }

    /**
    *   Ensure requested pipelines are valid
    */
    check_pipelines = { Map dependencies, List pipelines ->
        def unexpected_pipelines = []
        pipelines.each{ pipeline ->
            if (! dependencies.containsKey(pipeline)) {
                unexpected_pipelines.add(pipeline)
            }
        }

        if (unexpected_pipelines) {
            throw new Exception("### ERROR ### Found unexpected pipelines: ${unexpected_pipelines}. Expected selection from ${dependencies.keySet()}.")
        }
    }

    resolve_dependencies = { List requested_pipelines, Map pipeline_dependencies ->
        def dependencies_to_check = [] as Queue
        def pipelines_to_run = [] as Set

        requested_pipelines.each{ pipeline ->
            dependencies_to_check.offer(pipeline)
        }

        def curr_pipeline = ''
        while (curr_pipeline = dependencies_to_check.poll()) {
            pipelines_to_run.add(curr_pipeline)
            pipeline_dependencies[curr_pipeline].each{ dependency ->
                dependencies_to_check.offer(dependency)
            }
        }

        return pipelines_to_run as List
    }

    /**
    *   Entry point for selecting pipelines and identifying all pre-requisite pipelines for selection
    */
    get_pipelines = { List requested_pipelines=[], String input_type='BAM' ->
        def pipeline_dependencies = pipeline_selector.get_pipeline_dependencies(input_type)
        if (!requested_pipelines) {
            return pipeline_dependencies.keySet() as List
        }

        pipeline_selector.check_pipelines(pipeline_dependencies, requested_pipelines)

        return pipeline_selector.resolve_dependencies(requested_pipelines, pipeline_dependencies)
    }
}
